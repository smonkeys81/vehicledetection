#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
This is a style guideline checker of Robotics.

# Install dependencies
  '''bash
  $ sudo apt-get install libclang-6.0-dev
  $ pip install --user termcolor
  $ pip install --user clang
  '''

# Usage
  '''bash
  $ mkdir build
  $ cd build
  $ cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=On
  $ cd ..
  $ python coding_guideline_lint.py -h
  $ python coding_guideline_lint.py ./common/*.cpp -m ./ --name scripts/excep.txt --verbose
  '''

# License

Copyright 2019 Robotics, Inc. All Rights Reserved.

"""

import clang.cindex as ci
from termcolor import cprint, colored
from os import path as osp
from collections import OrderedDict as Od
import re
import argparse
import time
import glob
import subprocess
import datetime


block_writing_author = True
code_view_offset = 0 # It makes message shows more above, below code lines arround event code.

def is_headerfile(fn):
    _, ext = osp.splitext(fn)
    return ext == '.h'

def GetYearOfFile(fn):
    """
    Get creation year of given file as string.
    :param fn The filename.
    :return The creation year of file.
    """
    cmd = 'git log --format=%%aD %s | tail -1' % fn
    ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
    output = ps.communicate()[0]
    if len(output) > 0:
        first_line = output.split('\n')[0]
        year = first_line.split(' ')[3]
    else:
        now = datetime.datetime.now()
        year = '%d'%now.year
    return year

class StyleChecker:
    """
    The class look for the violation of guideline.
    """

    def __init__(self, module_dir, compilecommands_dir=None, naming_exception=set(),
             detect_hardcode=False, detect_deadcode=False):
        """
        :param module_dir Directory of module. The file out ouf module directory will bel ignored.
        :param compilecommands_dir The directory includes 'compile_commands.json'.
        :param naming_exception The directory to naming exception file which defines exceptions for naming check.
        :param detect_hardcode Whether try to detect hard coded numbers
        :param detect_deadcode Whether try to detect dead codes.
        compile_commands.json should be generated by cmake, with option CMAKE_EXPORT_COMPILE_COMMANDS=On.
        """
        # Check existance of directory.
        assert osp.isdir(module_dir), "The module path is wrong."
        self.module_dir = osp.realpath(module_dir)

        # CompilationDatabase provides c++ flag options.
        if compilecommands_dir is not None:
            assert osp.isdir(compilecommands_dir), "The compilecommands directory is wrong."
            assert osp.isfile(osp.join(compilecommands_dir, 'compile_commands.json')), \
                    "There is no compile_commands.json file."
            self.compdb = ci.CompilationDatabase.fromDirectory(compilecommands_dir)
        else:
            self.compdb = None

        # The messages are stored on below string during parsing.
        # After finish all parsing, the results are printed at once.
        self.success_messages = ''
        self.failure_messages = ''

        self.naming_exception = naming_exception
        self.detect_hardcode = detect_hardcode
        self.detect_deadcode = detect_deadcode

    def add_success(self, msg):
        '''
        Add given message to for success cases.
        The message is visible only for verbose mode.
        :param msg The new message to be appended.
        '''
        self.success_messages += msg +'\n'

    def add_failure(self, msg):
        '''
        Add given message to failure cases.
        The message is visible all the time.
        :param msg The new message to be appended.
        '''
        self.failure_messages += msg+'\n'

    def get_translation_unit(self, fn):
        """
        Get translation unit of clang.
        :param fn The cpp|h file name.
        :return Translation unit of clang.
        """
        base, ext = osp.splitext(fn)
        fn = osp.realpath(fn)
        args = []

        # If this is not headerfile, it should check the declaration in header files, too avoid asking comments double time.
        if not is_headerfile(fn):
            if self.compdb is not None:
                compilecommand = self.compdb.getCompileCommands(fn)
                if compilecommand is not None:
                    for i in xrange(len(compilecommand)):
                        args = [a for a in compilecommand[i].arguments]

            # If there is something wrong in cmake, clang can't find complie commands for given fn.
            if len(args) == 0:
                self.add_failure(colored("Misc","blue", attrs=['bold'])\
                        +": failed to get compile commands for " + osp.relpath(fn))

        index = ci.Index.create()
        if len(args) > 0:
            # If it has c++ arguments, including header information, get translation unit with them.
            tu = index.parse(fn, args=args[:-1])
            return tu

        # Create translation unit, without the header information.
        tu = index.parse(fn, args=['-std=c++11'])
        return tu

    def collect_usr(self, fn, tu):
        '''
        Collect USR (Unified Symbol Resolution) from header files of the module.
        It is necessary to avoid asking comments at definition, when their is a declaration in header file.
        :param fn The cpp|h filename.
        :param tu The translation unit
        :return The set structure which contains USR strings.
        '''
        usr_collection = set()
        for cursor in tu.cursor.walk_preorder():
            if cursor.location.file is None:
                continue
            elif not cursor.location.file.name.startswith(self.module_dir):
                continue
            elif cursor.location.file.name == osp.realpath(fn):
                continue
            elif cursor.kind not in [ci.CursorKind.FUNCTION_DECL,
                    ci.CursorKind.FUNCTION_TEMPLATE,
                    ci.CursorKind.CLASS_DECL,
                    ci.CursorKind.CONSTRUCTOR,
                    ci.CursorKind.CXX_METHOD,
                    ci.CursorKind.DESTRUCTOR,
                    ci.CursorKind.CLASS_TEMPLATE,
                    ]:
                continue
            usr = cursor.get_usr()
            usr_collection.add(usr)
        return usr_collection

    def check_entire(self, fn):
        '''
        Check the entire guideline rules.
        :param fn The cpp|h filename.
        :return It returns the number of rules what it checks.
        '''

        tu = self.get_translation_unit(fn)
        usr_collection = self.collect_usr(fn, tu)

        # Read the source code.
        f_org = open(fn, 'r')
        contents = f_org.read()
        f_org.close()

        # Split the codes with line.
        ln_contents = contents.split('\n')

        # Print file name before showing analysis.
        fn_msg = "About file : " + colored(osp.relpath(fn), 'white', attrs=['bold'])
        self.add_success(fn_msg)
        self.add_failure(fn_msg)

        # Check each guideline rules.
        number_of_check = 0
        number_of_check += self.check_codes(fn, tu, usr_collection, ln_contents)
        number_of_check += self.check_file_naming(fn)
        number_of_check += self.check_license_headerguard(fn, tu)
        number_of_check += self.check_misusing_nullptr(ln_contents)
        if self.detect_deadcode:
            number_of_check += self.check_dead_codes(tu)
        if self.detect_hardcode:
            number_of_check += self.check_hardcoded_number(tu, ln_contents)
        return number_of_check

    def check_file_naming(self, fn):
        '''
        Check naming of file.
        :param fn The file name.
        '''
        base = osp.basename(fn)
        # Check filename, whether it includes upper case.
        if base[0] != base[0].lower():
            self.add_failure( colored('First of filename should be lower. ', 'yellow')\
                    + colored(fn, 'blue') )
            self.add_failure('-------------------------')
        else:
            self.add_success( colored('It pass file naming test.', 'green') )
            self.add_success('-------------------------')
        return 1

    def check_misusing_nullptr(self, ln_contents):
        '''
        It assume usage of NULL as violation.
        :param ln_contents The list of code lines.
        '''
        violations = []

        # Search forl NULL
        for i, line in enumerate(ln_contents):
            x = re.search(r'\bNULL\b', line)
            if x is not None:
                violations.append(i)

        # Create messages for violations.
        if len(violations) > 0:
            self.add_failure(colored('Don\'t use NULL instead of nullptr.', 'red'))
            for i in violations:
                self.add_failure('%d|%s' % (i, ln_contents[i]))
            self.add_failure('-------------------------')
        else:
            self.add_success(colored('It doesn\'t misuse NULL.', 'green'))
            self.add_success('-------------------------')
        return max(1, len(violations))

    def check_codes_abusing_namespace(self, fn, cursor, token):
        '''
        It assume usage of using namespace at headerfile as violation.
        :param cursor clang cursor.
        '''
        if token.spelling == 'using':
            return [], []

        # Search for 'using' at the codes.
        parent = cursor.lexical_parent
        check_list = ['using']
        error_messages = []

        # Create message for the violations.
        if cursor.kind == ci.CursorKind.USING_DIRECTIVE:
            msg = colored('Don\'t use \'using namespace\'. use \'using declaration\'.', 'red')
            error_messages.append(msg)
        elif cursor.kind == ci.CursorKind.USING_DECLARATION:
            parent = cursor.lexical_parent
            if is_headerfile(fn) and parent.kind in [ci.CursorKind.TRANSLATION_UNIT,
                                                     ci.CursorKind.NAMESPACE ]:
                # Erorr
                msg = colored('\'using declaration\' is out of function|method\'s brace at header file.', 'red')
                error_messages.append(msg)
            #else:
            # Not recommeded, but proper.
        else:
            check_list = []
        return check_list, error_messages

    def check_dead_codes(self, tu):
        '''
        It detects dead codes in comments.
        :param fn The file name.
        :param tu clang translation unit.
        '''
        reg_ex = r'.*[\;\}\{]+.*'

        for token in tu.get_tokens(extent=tu.cursor.extent):
            if token.kind != ci.TokenKind.COMMENT:
                continue
            comments = token.spelling
            dead_codes = False
            if re.search(reg_ex, comments) is not None:
                dead_codes = True

            if dead_codes:
                self.add_failure(colored('Dead codes including \';, {, }\'', 'red'))
                ln0 = token.extent.start.line
                output_line = colored('%d|%s' %(ln0, token.spelling),'green')
                self.add_failure(output_line)
                self.add_failure('Denote that we use following regex to detection.')
                self.add_failure(reg_ex)

        return 1

    def check_hardcoded_number(self, tu, ln_contents):
        '''
        It detects hard coded numbers in code.
        :param tu clang translation unit.
        :param ln_contents The list of code lines.
        '''

        reg_ex1= r'(\w+)\s*=\s*(-?\s*[0-9.]+)\s*;'
        reg_ex2= r'(\w+)\(\s*(-?\s*[0-9.]+)\s*\);'
        for i, line in enumerate(ln_contents):
            # Search magic number
            r = re.search(reg_ex1, line)
            if r is None:
                r = re.search(reg_ex2, line)

            if r is not None:
                variable, number = r.groups()
                # Consider below numbers are not a magic number.
                if number in ['0', '0.', '-1', '-1.', '1', '1.0', '1.']:
                    continue
                self.add_failure(colored('Hard codes including number %s'%number, 'red'))
                output_line = '%d|%s' %(i, line)
                self.add_failure(output_line)

        return 1

    def check_license_headerguard(self, fn, tu):
        '''
        It confirm license and headerguards at first of headerfile.
        :param fn The file name.
        :param tu clang translation unit.
        '''

        # Collect comment token from the first of file.
        gen = tu.get_tokens(extent=tu.cursor.extent)
        first_token = ''
        header_guards = []
        while True:
            token = next(gen)
            if token.kind != ci.TokenKind.COMMENT:
                # header_guards[0] should be '#' of "#ifndef ~~~"
                header_guards = [token.spelling]
                break
            first_token += token.spelling + '\n'

        # Collect other two elements of header_guards, i.e., 'ifndef', 'HEADER_GUARD'.
        for i in range(2):
            header_guards.append(next(gen).spelling)

        # Regex to check license, comments, author.
        year = GetYearOfFile(fn)
        reg_ex_license = r'(Copyright © %s Robotics, Inc. All Rights Reserved.(\n|$))'%year
        reg_ex_explain = r'(\bThis(\s.*)?\sfile\b)'
        reg_ex_author = r'((author|Author|contact|Contact))'
        has_proper_license = False
        if len(first_token) > 0:
            line_license = re.search(reg_ex_license, first_token)
            line_explain = re.search(reg_ex_explain, first_token)
            line_ex_author = re.search(reg_ex_author, first_token)

            # If there is no license at first comments,
            if line_license is None:
                self.add_failure(colored('No proper copyright at First.', 'red'))
                self.add_failure('Denote that we use following regex to check license.')
                self.add_failure(reg_ex_license)

            # If there is no explane about file at first comments,
            if line_explain is None:
                self.add_failure(colored('No file explain for first token.', 'red'))
                self.add_failure('Denote that we use following regex to check file explain.')
                self.add_failure(reg_ex_explain)

            if not block_writing_author:
                # If there is no author, which supposed to be,
                if line_ex_author is None:
                    self.add_failure(colored('No Author contact for first token.', 'red'))
                    self.add_failure('Denote that we use following regex to check file contact.')
                    self.add_failure(reg_ex_author)
            else:
                # If there is author, which is forbiden,
                if line_ex_author is not None:
                    self.add_failure( colored('Don\' write author.', 'red') )
                    self.add_failure( 'Denote that we use following regex to check file contact.')
                    self.add_failure( reg_ex_author)

            if line_license is not None and line_explain is not None and line_ex_author is not None:
                has_proper_license = True
        else:
            # If the first token of the file is not commetns,
            self.add_failure( colored('First token of file must be license.', 'red'))
            self.add_failure('-------------------------')
        if has_proper_license:
            self.add_success( colored('It pass license test', 'green'))
            self.add_success('-------------------------')
        number_of_check = 3 # license, file explain, author

        if is_headerfile(fn):
            number_of_check += 1
            proper_header_guards = False
            base = osp.basename(fn)
            base, _ = osp.splitext(base)
            base = base.replace('_', '') # Remove _ from filenam

            if header_guards[1] =='ifndef':
                # Check header guards
                line_header_guard = re.search(r'ROBOTICS_([A-Z,0-9]*)_([A-Z,0-9]*)_H_', header_guards[2])
                if line_header_guard is not None:
                    fn_part = line_header_guard.groups()[1]
                    if fn_part == base.upper():
                        proper_header_guards = True

            # Create message
            if not proper_header_guards:
                expected_header_guard = colored('\'#ifndef ROBOTICS_', 'white')\
                        + colored('MODULE', 'yellow', attrs=['bold']) \
                        + colored('_%s_H_\''%base.upper(), 'white')
                self.add_failure( colored('Header guard ','red') \
                        + expected_header_guard \
                        + colored(' must be exist after license.', 'red'))
                self.add_failure('-------------------------')
            else:
                self.add_success(colored('It pass header guard test', 'green') )
                self.add_success('-------------------------')
        return number_of_check


    def check_codes_ifbrace(self, token):
        '''
        It forces writing brace and newline at if statement
        :param token clang token
        :return check_list, error_messages
        The method puts the name of the rule, what it considers, to check_list.
        If there is some violation, error_messages will bel appended.
        '''
        check_list, error_messages = [], []

        # Abort check if the token is not a 'if'
        if token.spelling != 'if':
            return check_list, error_messages
        check_list.append('ifbrace')
        cursor = token.cursor
        if cursor.extent.start.line == 0:
            return check_list, error_messages

        # Count depth of parenthesis '(, )'
        found_brace = False;
        parenthesis_depth = 0
        for child in cursor.get_tokens():
            if child.spelling == '(':
                parenthesis_depth += 1
                found_parenthesis = True
            if child.spelling == ')':
                parenthesis_depth -= 1
            if parenthesis_depth == 0 and child.spelling == '{':
                found_brace = True
                break

        # If there is no '{' bracket after parenthesis, create message for the violation.
        if not found_brace:
            msg = colored('Must use brace \'{\'.', 'red')
            error_messages.append(msg)
        if cursor.extent.start.line == cursor.extent.end.line:
            msg = colored('Must newline after if condition.', 'red')
            error_messages.append(msg)

        return check_list, error_messages

    def check_codes_class(self, cursor, above_comments, ln_contents):
        '''
        Check comments, naming of class.
        :param cursor clang Cursor.
        :param above_comments comments above the cursor.
        :param ln_contents The list of code lines.
        '''

        check_list = []
        error_messages = []
        if cursor.kind in [ci.CursorKind.CLASS_DECL, ci.CursorKind.CLASS_TEMPLATE, ci.CursorKind.STRUCT_DECL]:
            # Classify type of cursor.
            if cursor.kind == ci.CursorKind.STRUCT_DECL:
                cursor_kind = 'struct'
            else:
                cursor_kind = 'class'
            check_list.append('cursor_kind')
            check_list.append('naming')

            # If that is not a forward declaration,
            if cursor.extent.start.line != cursor.extent.end.line:
                # Check comments \class or \struct.
                if re.search(r'\/\/\/\s\\%s\s(.*)(\n|$)'%cursor_kind, above_comments) is None:
                    msg = colored('No \\%s comments'%cursor_kind, 'red') \
                            + ' for ' + colored(cursor.spelling, 'blue')
                    error_messages.append(msg)

                # Check naming of class/struct. First spelling of those should be uppe case.
                if cursor.spelling not in self.naming_exception:
                    if cursor.spelling[0] != cursor.spelling[0].upper():
                        msg = colored('First of %s name should be upper case. '%cursor_kind, 'yellow') \
                                + colored(cursor.spelling[0], 'blue', 'on_grey', attrs=['bold']) \
                                + colored(cursor.spelling[1:], 'white')
                        error_messages.append(msg)
        return check_list, error_messages

    def check_codes_brief(self, cursor, above_comments):
        '''
        Check brief comments for the given cursor.
        :param cursor clang Cursor.
        :param above_comments comments above the cursor.
        '''
        check_list = []
        error_messages = []
        # If cursor.kind belong to function,class,methods
        if cursor.kind in [ci.CursorKind.FUNCTION_DECL,
                           ci.CursorKind.FUNCTION_TEMPLATE,
                           ci.CursorKind.CXX_METHOD,
                           ci.CursorKind.CONSTRUCTOR,
                           ci.CursorKind.DESTRUCTOR,
                           ci.CursorKind.FIELD_DECL,
                           ci.CursorKind.DESTRUCTOR]:
            # Check existance of \brief
            check_list.append('brief')
            if re.search(r'\/\/\/\s\\brief\s(.*)(\n|$)', above_comments) is None:
                msg = colored('No \\brief comments', 'red') \
                        + ' for ' + colored(cursor.spelling, 'blue')
                error_messages.append(msg)
        return check_list, error_messages

    def check_codes_return(self, cursor, above_comments, ln_contents):
        '''
        Check return comments and naming of the function.
        :param cursor clang Cursor.
        :param above_comments comments above the cursor.
        :param ln_contents The list of code lines.
        '''

        check_list = []
        error_messages = []
        ln = ln_contents[cursor.extent.start.line-1]
        # If return type of the function is void, don't look for return comments.
        if re.search(r'\bvoid\s+%s\b'%cursor.spelling, ln) is None:
            if cursor.kind in [ci.CursorKind.FUNCTION_DECL,
                               ci.CursorKind.FUNCTION_TEMPLATE,
                               ci.CursorKind.CXX_METHOD,
                               ]:
                check_list.append('return')

                # Find \return comments with regex
                if re.search(r'\/\/\/\s\\return\s(.*)(\n|$)', above_comments) is None:
                    msg = colored('No \\return comments', 'red') \
                            + ' for ' + colored(cursor.spelling, 'blue')
                    error_messages.append(msg)

        # Check naming of function.
        # main function is a exception.
        if cursor.spelling not in self.naming_exception:
            if cursor.kind in [ci.CursorKind.FUNCTION_DECL,
                               ci.CursorKind.FUNCTION_TEMPLATE,
                               ci.CursorKind.CXX_METHOD] \
                                       and cursor.spelling != 'main':
                check_list.append('naming')
                if cursor.spelling[0] != cursor.spelling[0].upper():
                    msg = colored('First of (function|method) name should be upper case. ', 'yellow') \
                            + colored(cursor.spelling[0], 'blue', 'on_grey', attrs=['bold']) \
                            + colored(cursor.spelling[1:], 'white')
                    error_messages.append(msg)
        return check_list, error_messages

    def check_codes_params(self, cursor, above_comments):
        '''
        Check param comments for given cursor.
        :param cursor clang Cursor.
        :param above_comments comments above the cursor.
        '''

        check_list = []
        error_messages = []

        # Check \param
        if cursor.kind in [ ci.CursorKind.FUNCTION_DECL,
                ci.CursorKind.FUNCTION_TEMPLATE,
                ci.CursorKind.CXX_METHOD,
                ci.CursorKind.CONSTRUCTOR,
                ci.CursorKind.DESTRUCTOR] or hasattr(cursor, 'is_constructor'):

            # Collect parameter names. Those are front of comma or parenthesis.
            # Calculate depth of parenthesis, because of STL containers or default values of parameter.
            # Such as ..
            # void func(std::map<int,int> m, int n = (int) -3);

            param_name_in_code = set()
            parenthesis_depth = 0
            b_start_param = False
            pprevious_token = None
            previous_token = None
            for token in cursor.get_tokens():
                # Continue until first parenthesis '('
                if token.spelling == '(':
                    b_start_param = True
                    continue
                if not b_start_param:
                    continue

                # After frist parenthesis
                # Count depth of parenthesis, to ignore tokens in other parenthesis
                # Such as <int,int> or (int) at a example "void func(std::map<int,int> m, int n = (int) -3);"
                if parenthesis_depth == 0:
                    if token.spelling in [',', ')', '=', '['] and previous_token is not None:
                        if pprevious_token is None:
                            param_name_in_code.add(previous_token.spelling)
                        elif pprevious_token.spelling != '=' and previous_token.spelling is not ']':
                            param_name_in_code.add(previous_token.spelling)
                if token.spelling in ['(','<']:
                    parenthesis_depth += 1
                if token.spelling in [')','>']:
                    parenthesis_depth -= 1
                if parenthesis_depth == -1:
                    break
                pprevious_token = previous_token
                previous_token = token

            # Check every param comments exist at c++ codes or not
            params_in_comments = re.findall(r'\\param\[(in|out|in,out)\]\s+([^\s]+)(.*)(\n|$)', above_comments)
            close_set = set()
            for inout_type, param_name, param_comment, _ in params_in_comments:
                if param_name not in param_name_in_code:
                    msg = colored(param_name, 'blue') \
                            + colored(' is not a parameter of ', 'red') \
                            + colored(cursor.spelling, 'blue')
                    error_messages.append(msg)
                elif param_name in close_set:
                    msg = colored(param_name, 'blue') \
                            + colored(' has too many comments.', 'red')
                    error_messages.append(msg)
                close_set.add(param_name)

            # Check every parameters of c++ codes have comments
            for child_name in param_name_in_code:
                # Type of param must be in, out or 'in,out'.
                reg_ex = r'\/\/\/\s\\param\[(in|out|in,out)\]\s%s\s(.*)(\n|$)' % child_name
                x = re.search(reg_ex, above_comments)
                check_list.append('param')
                if x is None:
                    msg = colored('No \\param comments', 'red') \
                            + ' for ' + colored(child_name, 'blue')
                    error_messages.append(msg)
                check_topic = 'param naming'
                if check_list[-1] != check_topic:
                    check_list.append(check_topic)

                # Check naming convention of parameter variable.
                if child_name not in self.naming_exception:
                    if child_name != child_name.lower():
                        msg = colored('Variable name should be lower case. ', 'yellow') \
                                + colored(child_name, 'blue')
                        error_messages.append(msg)
        return check_list, error_messages



    def check_codes(self, fn, tu, usr_collection, ln_contents):
        '''
        It calls 'self.check_codes_[\w]+' methods..
        :param fn The file name.
        :param tu clang translation unit.
        :param usr_collection The collectiosn of unified symbolic resolution.
        :param ln_contents The list of code lines.
        '''

        # Collect tokens from first to end of the file.
        all_tokens = []
        for token in tu.get_tokens(extent=tu.cursor.extent):
            all_tokens.append(token)

        _, ext = osp.splitext(fn)
        success_block = []
        failure_block = []
        for token in all_tokens:
            cursor = token.cursor

            # Check ifbrace rule.
            if token.spelling == 'if':
                check_list, error_messages = self.check_codes_ifbrace(token)
                ln0 = cursor.extent.start.line-1
                ln_arround = (ln0-1, ln0+2)
                block = (cursor, ln0, ln_arround, '', check_list, error_messages)
                if len(error_messages) == 0:
                    success_block.append(block)
                else:
                    failure_block.append(block)

            if cursor is not None:
                # Abusing namespace test
                check_list, error_messages = self.check_codes_abusing_namespace(fn, cursor, token)
                if len(check_list) > 0:
                    ln0 = cursor.extent.start.line-1
                    ln_arround = (ln0-1, ln0+1)
                    block = (cursor, ln0, ln_arround, '', check_list, error_messages)

                    # Classify success cases and failure cases for the convention test.
                    if len(error_messages) == 0:
                        success_block.append(block)
                    else:
                        failure_block.append(block)

            if token.kind != ci.TokenKind.IDENTIFIER:
                continue
            if cursor.kind is ci.CursorKind.DESTRUCTOR:
                if '~'+token.spelling != cursor.spelling:
                    continue
            elif token.spelling != cursor.spelling:
                continue

            usr = cursor.get_usr()

            # If the usr already declared from other headerfile, pass it.
            if usr in usr_collection:
                continue

            # Ignore keyword about qt meta object
            if cursor.spelling == 'Q_OBJECT':
                continue

            if cursor.kind in [ci.CursorKind.FUNCTION_DECL,
                               ci.CursorKind.FUNCTION_TEMPLATE,
                               ci.CursorKind.CXX_METHOD,
                               ci.CursorKind.CLASS_DECL,
                               ci.CursorKind.FIELD_DECL,
                               ci.CursorKind.CLASS_TEMPLATE,
                               ci.CursorKind.CONSTRUCTOR,
                               ci.CursorKind.DESTRUCTOR]:

                # Collect the above comments
                i0 = all_tokens.index(token)
                i1 = i0

                while True:
                    token0 = all_tokens[i0]
                    if token0.kind in [ci.TokenKind.PUNCTUATION, ci.TokenKind.LITERAL]:
                        if token0.spelling in [';', '}', '{']:
                            break
                        cursor0 = token0.cursor
                        if cursor0 is not None:
                            if cursor0.kind == ci.CursorKind.INVALID_FILE:
                                break
                    if i0 == 0:
                        break
                    i0 -= 1

                # Collect the token including parameters in round bracket ().
                token1 = all_tokens[i1]
                if cursor.kind in [ci.CursorKind.FUNCTION_DECL,
                                   ci.CursorKind.FUNCTION_TEMPLATE,
                                   ci.CursorKind.CXX_METHOD,
                                   ci.CursorKind.CONSTRUCTOR,
                                   ]:
                    while True:
                        token1 = all_tokens[i1]
                        if token1.spelling == ')':
                            if token1.cursor.semantic_parent == cursor.semantic_parent:
                                break;
                        i1 += 1

                # ln0 : The line number at first of comments.
                # ln1 : The line number at end of comments.
                ln0 = token0.extent.end.line -1
                ln1 = token.extent.start.line-1

                if ln0 == ln1:
                    above_comments = ''
                else:
                    above_comments = '\n'.join(ln_contents[ln0:ln1])

                ln_arround = (ln0-code_view_offset, token1.extent.end.line+code_view_offset)

                # check_list : It collects inspection items.
                check_list = []
                error_messages = []

                #cursor = token.cursor
                if token0.extent.start.line >= cursor.extent.start.line:
                    cursor.is_constructor=True
                else:
                    a,b = self.check_codes_class(cursor, above_comments, ln_contents)
                    check_list += a
                    error_messages += b

                # Do inspections.
                for f in [ self.check_codes_brief, self.check_codes_params]:
                    a, b = f(cursor, above_comments)
                    check_list += a
                    error_messages += b

                for f in [ self.check_codes_return]:
                    a, b= f(cursor, above_comments, ln_contents)
                    check_list += a
                    error_messages += b

                # Append messages.
                if len(error_messages) == 0:
                    success_block.append( (cursor, ln0, ln_arround, above_comments, check_list, error_messages) )
                else:
                    failure_block.append( (cursor, ln0, ln_arround, above_comments, check_list, error_messages) )
        # end for token in all_tokens

        # Print result of the inspections.
        n_checklist_of_file = 0
        for i, (cursor, ln0, ln_arround, above_comments, check_list, error_messages) in enumerate(success_block+failure_block):
            n_checklist_of_file += len(check_list)
            # Show check list
            if i < len(success_block) :
                self.add_success(str(check_list))
            else:
                self.add_failure(str(check_list))
                # Show error, i.e., advice message.
                for msg in error_messages:
                    self.add_failure(msg)

            # Show code lines about style check.
            for j in range(ln_arround[0], ln_arround[1]):
                l = ln_contents[j]
                if j == cursor.extent.start.line-1:
                    output_line =  colored('%d|%s' %(j+1, l), 'white', 'on_grey')
                elif j > ln0 and j < cursor.extent.start.line-1:
                    output_line = colored('%d|%s' %(j+1, l),'green')
                else:
                    output_line =  '%d|%s' %(j+1, l)
                if i < len(success_block) :
                    self.add_success(output_line)
                else:
                    self.add_failure(output_line)
            # Show section segment
            if i < len(success_block) :
                self.add_success('-------------------------')
            else:
                self.add_failure('-------------------------')

        return n_checklist_of_file




if __name__ == '__main__':
    # Specify clang verison.
    ci.Config.set_library_file('/usr/lib/x86_64-linux-gnu/libclang-6.0.so')

    # Get arguments for the script.
    arg_parser = argparse.ArgumentParser(description='Check style guide for given code')
    arg_parser.add_argument('fn', metavar='filepath', type=str, nargs='+',
            help='filepath to check.')
    arg_parser.add_argument('-m', metavar='modulepath', type=str, nargs='?',
            help='It limits dir of your headerfiles')
    arg_parser.add_argument('--name', metavar='exeptiontext', type=str, nargs='?',
            help='The file is list of naming exception')
    arg_parser.add_argument("-v", "--verbose", help="It make success messages be visible.",
            action="store_true")
    arg_parser.add_argument("-a", "--advanced", help="Try to detect dead/hard codes also.",
            action="store_true")
    args = arg_parser.parse_args()

    # Glob exception namings which allowed to violate naming convention.
    # e.x) Methods inherited by other library.
    naming_exception = set()
    if args.name is not None:
        naming_exception = map(str.strip, open(args.name, "r").readlines())
        naming_exception = set(naming_exception)

    # Create StyleChecker based on arguments.
    if args.m is not None:
        # The module directory
        mdir = args.m[0]

        # The build directory which include 'compile_commands.json' file.
        bdir = '%s/build'%mdir

        # Confirm the build directory
        if not osp.isfile(osp.join(bdir, 'compile_commands.json')) :
            bdir = None

        code_parser = StyleChecker(mdir, bdir, naming_exception,
                detect_hardcode=args.advanced, detect_deadcode=args.advanced)
    else:
        # If there is no given module directory.
        code_parser = StyleChecker('./', None, naming_exception,
                detect_hardcode=args.advanced, detect_deadcode=args.advanced)



    # The scripts work even user inputs './somepath/*.cpp' or './somepath/*.h' for file names.
    fn_list = []
    for each_fn in args.fn:
        fn_list += glob.glob(each_fn)
    for each_fn in fn_list:
        _, ext = osp.splitext(each_fn)
        if ext not in ['.cpp', '.h']:
            continue
        code_parser.check_entire(each_fn)

    # If verbose mode, print success cases also.
    if args.verbose:
        print code_parser.success_messages
        print colored(" ============= ", "white", attrs=['bold']) \
                + colored(" ↑ Success", 'green', attrs=['bold']) \
                + " / " \
                + colored("Failure ↓ ", 'red', attrs=['bold']) \
                + colored(" ============= ", "white", attrs=['bold'])
    print code_parser.failure_messages

